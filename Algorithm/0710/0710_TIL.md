# 0710_TIL

최근 알고리즘 스터디를 진행하며 새롭게 배운 세 가지 알고리즘에 대해 정리하고자 한다.

## 누적 합

[백준 10986 나머지 합](https://www.acmicpc.net/problem/10986) 을 풀이하는 과정에서 누적합 개념을 활용해야 했다. 처음에는 단순하게 아래와 같이 풀이를 진행했다.

```python
N, M = map(int, input().split())
arr = list(map(int, input().split()))
cnt = 0
for i in range(N):
    num = 0
    for j in range(i, N):
        num += arr[j]
        if num % M == 0:
            cnt += 1
print(cnt)
```

이 풀이 역시 틀린 것은 아니지만 O(n^2)의 시간 복잡도를 가지기 때문에 시간초과로 오답 처리가 되었다. 이 과정에서 풀이 시간을 줄이기 위해 누적 합 개념을 활용해야 한다는 것을 알게 되었다.

누적 합이란 말 그대로 나열된 수의 누적된 합을 의미한다. 수열 An에 대해 1부터 N까지의 합을 각각 N번째 인덱스에 작성한 것을 의미한다. 10986번 역시 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 문제이기 때문에 누적합을 활용해 코드를 작성할 경우, 더욱 빠르게 문제를 해결할 수 있다. 

누적합이 작성되어 있는 수열을 S라고 했을 때, 문제에서 원하는 것은 `S[j]-S[i-1]` 이 M으로 나누어 떨어지는 (i, j) 쌍의 경우의 수이고 이를 수식으로 표현할 경우 `(S[j] - S[i-1] )% M == 0` 입니다. 이를 다시 풀어 작성하면 `S[j] % M == S[i-1] % M` 으로 나타낼 수 있기 때문에, 결국 정답은 앞의 수식, 즉, 나머지가 같은 누적합 구간 2개를 조합해 갯수를 세어주면 됩니다.

```python
N, M = map(int, input().split())
a = list(map(int, input().split())) + [0]
cnt = [0] * M

for i in range(N):
    a[i] += a[i - 1]
    cnt[a[i] % M] += 1

ans = cnt[0]

for v in cnt:
    ans += v * (v - 1) // 2

print(ans)
```

위 코드는 앞서 생각했던 풀이 방법을 파이썬 코드로 구현한 것입니다.

1. 먼저 각 구간의 누적합을 구해줍니다. 
2. 각 구간의 누적합을 M으로 나누었을 때의 나머지의 갯수를 새로운 배열에서 세어줍니다. 
3. 이미 구간합이 M으로 나누어 떨어지는 경우에는, 수열의 첫번째 수부터 해당하는 구간까지가 정답의 경우의 수 중 하나이기 때문에 이를 먼저 정답에 더해줍니다.
4. 이후, 나머지가 같은 구간 중 서로 다른 2개를 고를 경우 해당하는 구간이 정답의 조건을 만족하기 때문에 해당하는 경우의 수를 계산합니다. 이 과정에서 (i, j)와 (j, i)는 같은 경우이기 때문에 2로 나누어 정답에 더해줍니다.



